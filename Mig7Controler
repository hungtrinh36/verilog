////////////////////////////////////////////////////////////////////////////////
//
// Arrive Technologies
//
// Filename     : xilddr3_appdiag.v
// Description  : .
//
// Author       : hungtp@ES-TPHUNG
// Created On   : Tue Apr 21 20:34:41 2015
// History (Date, Changed By)
//
////////////////////////////////////////////////////////////////////////////////
//`define TB_ON_ARRIVE_SIMRAM
`define RTL_DEBUG

module xilddr3_appdiag
    (
     clk,
     rst_,

     app_addr,      // address
     app_cmd,       // command
     app_en,        // anable

     app_wdf_data,  // Write data
     app_wdf_end,   //
     app_wdf_mask,  // Write data mask 8/1
     app_wdf_wren,  
     
     app_rd_data,   // read data
     app_rd_data_end,
     app_rd_data_valid,
     
     app_rdy,
     app_wdf_rdy,
     app_sr_req,
     app_ref_req,
     app_zq_req,
     app_sr_active,
     app_ref_ack,
     app_zq_ack,

     init_calib_complete,
     
     otestmode, // output test mode
     ostate,    // state out for debug
     odev_temp, // device temperature.
     // -- CPU interface -------------------
     upce_,
     uprnw,
     upa,
     updi,
     updo,
     upack     
     );
////////////////////////////////////////////////////////////////////////////////
// Parameter declarations
parameter              DDRDQ = 32;// DDR3 32 bit
parameter              DDRA = 13; // DDR3 Address (2Gb)
parameter              CPUA = 8; // CPU address 8-24 bit
parameter              CPUD = 32; // CPU data 32 bit

parameter              ROW = 14;
parameter              BANK = 3;
parameter              COL = 10;
parameter              RANK = 0;  // Single rank, DIM only
parameter              ADDRW = (RANK + BANK + ROW + COL);
parameter              DATAW = DDRDQ*4*2; // Double data rate

parameter              MAX_ADDR = 10;
// State machine (FSM):
parameter              IDLE       = 0;
parameter              WRITE      = 1;
parameter              READ       = 2;
parameter              WAIT       = 3;
// Refresh:
parameter              USER_RF = "ON";// "OFF"
////////////////////////////////////////////////////////////////////////////////
// Port declarations
// Inouts
input                  clk;   // using ui_clk output from IP
input                  rst_;  // using synce_rst_ output from IP
// User interface signals
output [ADDRW-1:0]     app_addr; // rank+row+bank+col
output [2:0]           app_cmd;
output                 app_en;

output [DATAW-1:0]     app_wdf_data;
output                 app_wdf_end;
output [DATAW/8-1:0]   app_wdf_mask;
output                 app_wdf_wren;

input [DATAW-1:0]      app_rd_data;
input                  app_rd_data_end;
input                  app_rd_data_valid;

input                  app_rdy;      // app ready
input                  app_wdf_rdy;  // app ready for write cycle
// sr: reserved signals => connect to 0
// ref: refresh DDR: 
output                 app_sr_req;   // Should connect to 1'b0;
output                 app_ref_req;  // Should connect to 1'b0;
output                 app_zq_req;   // Should connect to 1'b0;

input                  app_sr_active; 
input                  app_ref_ack;
input                  app_zq_ack;
// DDR calib OK, active high
input                  init_calib_complete;
output                 otestmode;// output test mode, sel diag or core RTL
output [1:0]           ostate;  // state out for debug
output [11:0]          odev_temp;// device temperature.
// -- CPU interface----------------------------------------------
input                  upce_;
input                  uprnw;
input [7:0]            upa;
input [31:0]           updi;
output [31:0]          updo;
output                 upack;  
////////////////////////////////////////////////////////////////////////////////
// Local logic and instantiation
wire                   clk;   // using ui_clk output from IP
wire                   rst_;  // using synce_rst_ output from IP
// User interface signals
wire [ADDRW-1:0]       app_addr,ddr_addr,o_addr; // rank+row+bank+col
wire [2:0]             app_cmd;
wire                   app_en;

wire [DATAW-1:0]       app_wdf_data;
wire                   app_wdf_end;
wire [DATAW/8-1:0]     app_wdf_mask;
wire                   app_wdf_wren;

wire [DATAW-1:0]       app_rd_data;
wire                   app_rd_data_end;
wire                   app_rd_data_valid;

wire                   app_rdy;      // app ready
wire                   app_wdf_rdy;  // app ready for write cycle
// sr: reserved signals => connect to 0
// ref: refresh DDR: 
wire                   app_sr_req = 1'b0;   // Should connect to 1'b0 side IP;
wire                   app_ref_req = 1'b0;  // Should connect to 1'b0 side IP;
wire                   app_zq_req = 1'b0;   // Should connect to 1'b0 side IP;

wire                   app_sr_active; 
wire                   app_ref_ack;
wire                   app_zq_ack;
// DDR calib OK, active high
wire                   init_calib_complete;
wire                   otestmode;// wire test mode, sel diag or core RTL
wire [1:0]             ostate;  // state out for debug
wire [11:0]            odev_temp;// device temperature.
// -- CPU interface----------------------------------------------
wire                   upce_;
wire                   uprnw;
wire [7:0]             upa;
wire [31:0]            updi;
wire [31:0]            updo;
wire                   upack;
wire                   upws,uprs;
//------------------------------------------------------------------------------
wire                   test_en,ddrtest_en,ddrok,addr_full,test_comp,otest_en;
wire [7:0]             wait_clk;
//wire [7:0]             addr_range; //00-ff= 0-256 address
wire [15:0]            addr_range; //00-ff= 0-256 address
wire                   wr_state,rd_state,idle_state,wait_state;
wire                   wr_state1,rd_state1,idle_state1,wait_state1;
wire                   posrd_state,poswr_state;
reg [7:0]              wait_cnt,valid_cnt;
wire                   wrcmd_win,rdcmd_win; 
wire                   app_rden;
wire [1:0]             data_mod;
wire [1:0]             addr_mod;
wire [1:0]             ddrtestmode; //  R/W,WWW/RRR
wire [ADDRW-1:0]       fix_addr;

fflopx #(1) pipe_ddrok (clk,rst_,init_calib_complete,ddrok);
fflopx #(1+1) fflsta   (clk,rst_,{wr_state,rd_state},{wr_state1,rd_state1});
assign                 poswr_state = (~wr_state1) & wr_state;
assign                 posrd_state = (~rd_state1) & rd_state;
//------------------------------------------------------------------------------
// Wait counter:
always @(posedge clk or negedge rst_)
    if (!rst_)         wait_cnt <= 16'h0;
    else if (wr_state | rd_state)  wait_cnt <= 16'h0;
    else if (wait_state) wait_cnt <= wait_cnt + 2'b1;
    else;
// Counter valid     
always @(posedge clk or negedge rst_)
    if (!rst_)
        valid_cnt <= 8'h0;
    else if (posrd_state)
        valid_cnt <= 8'h0;
    else if (poswr_state)
        valid_cnt <= 8'h0;
    else if (app_rd_data_valid)
        valid_cnt <= valid_cnt + 1'b1;

//////////////////////////////////////////////////////////////////////////////////
assign                 test_en = (ddrtest_en & ddrok);
// FSM:
reg [1:0]              state;

always @(posedge clk or negedge rst_)
    begin
    if (!rst_)
        begin
        state <= IDLE;
        end
    else
        begin
        case (state)            
            IDLE:
                begin
                if (~test_en)
                    state <= IDLE;
                else if (test_en)
                    state <= WRITE;                     
                else
                    state <= state;
                end
            WRITE:
                begin
                if (~test_en)
                    state <= IDLE;
                else if (addr_full & app_rdy)
                    //state <= READ;
                    state <= WAIT;              
                else
                    state <= state;             
                end
            WAIT:
                begin
                if (~test_en)                
                    state <= IDLE;
                else if ((wait_cnt == wait_clk) & app_rdy)
                    state <= READ;
                else
                    state <= state; 
                end
            READ:
                begin
                if (~test_en)                
                    state <= IDLE;             
                else if ((valid_cnt == addr_range) & app_rdy & app_wdf_rdy)                
                    state <= WRITE;
                else
                    state <= state;              
                end
            default: 
                state <= IDLE;         
        endcase
        end
    end
//------------------------------------------------------------------------------
// State :
assign          idle_state = (state == IDLE);
assign          wr_state   = (state == WRITE);
assign          rd_state   = (state == READ);
assign          wait_state = (state == WAIT);
assign          ostate     = state; // for bebug.

assign          wrcmd_win = (wr_state & app_rdy & app_wdf_rdy);
assign          rdcmd_win = (rd_state & app_rdy);
//------------------------------------------------------------------------------
// Gen command control IP:
assign          app_wdf_wren  = (wr_state & app_wdf_rdy);
assign          app_rden      = (rd_state & app_rdy & app_en);
assign          app_wren      = (app_wdf_wren & app_rdy & app_en);

assign          app_wdf_end   = app_wdf_wren;

assign          app_wdf_mask  = {(DATAW/8){1'b0}};
// app_cmd: 0/1/3/7 == Write/Read/Write_byte/Unknow.
assign          app_cmd = (wr_state ? 3'b000 : 
                           rd_state ? 3'b001 : 3'b111);
//------------------------------------------------------------------------------
// Hold app_en in read state is address range (make app_en wr_state = app_en rd_state):
/*                          __________________________________________
read_state ________________/                           \maxaddr       \read end
                           |1clk|<--- Notice:
                                 ______________________|1clk|_
rd_app_en  _____________________/                           \___________________
 
address for read:               /A0\____________________/An\________
                                \  /                    \  /
*/
// Counter address for read/write (==)!
// Move address counter to diag module:
//wire [15:0]     adrcnt;
reg [15:0]      adrcnt;
reg             rd_app_en;

always @(posedge clk or negedge rst_)
    if (~rst_)                      adrcnt <= 16'h0;
    else if (posrd_state)           adrcnt <= 16'h0;
    else if (adrcnt == addr_range)  adrcnt <= adrcnt;
    else if (app_rden)              adrcnt <= adrcnt + 1'b1;
    else; 

always @(posedge clk or negedge rst_)
    if (~rst_)                      rd_app_en <= 1'b0;
    else if (adrcnt == addr_range)  rd_app_en <= 1'b0; // delay 1clk
    else if (rd_state)              rd_app_en <= 1'b1; // delay 1clk
    else;


assign          app_en        = (wr_state ? wr_state   :
                                 rd_state ? rd_app_en  : 1'b0);
//------------------------------------------------------------------------------
// Addressing:
wire                   rd_adrfull;
reg [3:0]              num;                      
assign                 rd_adrfull = (addr_full & rd_state);
// INC address
wire                   posapp_en;
fflopx #(1) fflappen (clk,rst_,app_en,app_en1);
assign                 posapp_en = ((!app_en1) & app_en);

wire                   clean_addr;
//assign                 clean_addr = (idle_state | poswr_state | posrd_state | posapp_en);

assign                 clean_addr = (idle_state | wait_state | addr_full);

reg [ADDRW-1:0]        addrinc_in;
wire [ADDRW-1:0]       addrinc_out;
assign                 addrinc_out = (addrinc_in + 2'b1) ;

always @(posedge clk or negedge rst_)
    begin
    if(!rst_)
        addrinc_in <= {ADDRW{1'b0}};
    else if (~test_en)
        addrinc_in <= {ADDRW{1'b0}};
    else if (addrinc_out == addr_range)
        addrinc_in <= {ADDRW{1'b0}};
    else if (clean_addr)
        addrinc_in <= {ADDRW{1'b0}};
    else if(app_wren | app_rden)       
        addrinc_in <= addrinc_out;
    end

always @(posedge clk or negedge rst_)
    if (!rst_) num <= 4'h1;
    else if (rd_adrfull) num <= (num + addr_range + 1'b1);
    else;       
// Out addr 00/fix/INC/PRBS
assign                 o_addr = ( (addr_mod == 2'b01) ? fix_addr    : 
                                  (addr_mod == 2'b10) ? addrinc_out :  {ADDRW{1'b0}});
// Address seq [2:0] == 3'b000
assign                 ddr_addr = {(o_addr + num),3'b000}; // A[3:0] == 4'b0000 => R/w = 12345678
assign                 app_addr = (app_en & app_rdy) ? ddr_addr : {ADDRW{1'b0}};
// Address full -> loop operation
// Addr mode 00/fix/INC.
assign                 addr_full = ((addr_mod == 2'b00) ? 1'b1 :
                                    (addr_mod == 2'b01) ? 1'b1 :
                                    (addr_mod == 2'b10) ? ((o_addr == addr_range) ? 1'b1 : 1'b0) :
                                    (addr_mod == 2'b11) ? 1'b1 : //PRBS ADDR
                                    1'b1);
//------------------------------------------------------------------------------
// DDR data gen/mon:
// fix data
wire [3:0]             diag_alarm;

ddr_genmon      ddrgen_mondat   
    (
     .clk           (clk),
     .rst_          (rst_),
     // data gen mon:
     .odat          (app_wdf_data),
     .idat          (app_rd_data),
     // data enable
     .itest_en      (test_en),
     .istate        (state),
     .iwren         (app_wren),
     .ivalid        (app_rd_data_valid),
     // control data
     .iforceerr     (force_dataerr),
     .ifixdata      ({fixdat1,fixdat2}),
     .imod          (data_mod),
     .oalarm        (diag_alarm), // [0] rddaterr,[1] fifofull,[2] fifonot empty
     .o_comparedat  ()
     );
defparam        ddrgen_mondat.LEN = DATAW;
//------------------------------------------------------------------------------
// DDR3 refresh:




//------------------------------------------------------------------------------
//-----------------CPU interface------------------------------------------------
/*
 reg address:
 
 0x00 : enable test
 0x01 : sticky diag
 
 0x40 : counter error (ro)
 0x41 : counter read (ro) 
 0x42 : counter write (ro) 

 0x50 : counter error (r2c)
 0x51 : counter read (r2c) 
 0x52 : counter write (r2c)    
*/
rwsgen irwsgen
    (
     .clk           (clk),
     .rst_          (rst_),
     .pce_          (upce_),
     .prnw          (uprnw),
     .prs           (uprs),
     .pws           (upws),
     .scanmode      (1'b0)
     );

rdygen irdygen
    (
     .rst_          (rst_),
     .clk           (clk),
     .pce_          (upce_),
     .scanmode      (1'b0),
     .rdyin         (uprdy),
     .rdyout        (upack)
     );
// Ready
wire                   uprdy_cnt,uprdy_glb,uprdy_ctl;
wire                   uprdyx;
assign                 uprdyx = (uprdy_glb |
                                 uprdy_ctl |
                                 uprdy_cnt);

fflopx #(1) pipe_rdy (clk,rst_,uprdyx,uprdy);
////////////////////////////////////////////////////////////////////////////////
// Decode Address:
wire                   upen_glb     = (~upce_)    & (upa[7:4] == 4'b0000); // 00 -> 0f
wire                   upen_ctl     = (~upce_)    & (upa[7:4] == 4'b0001); // 10 -> 1f
wire                   upen_cntro   = (~upce_)    & (upa[7:4] == 4'b0100); // 40 -> 4f
wire                   upen_cntr2c  = (~upce_)    & (upa[7:4] == 4'b0101); // 50 -> 5f
// global reg
wire                   upen_glb0    = upen_glb   & (upa[3:0] == 4'b0000); // 00
wire                   upen_glb1    = upen_glb   & (upa[3:0] == 4'b0001); // 01
// counter reg
// Read only:
wire                   upen_cntro1  = upen_cntro & (upa[3:0] == 4'b0001); // 41-error
wire                   upen_cntro2  = upen_cntro & (upa[3:0] == 4'b0010); // 42-write
wire                   upen_cntro3  = upen_cntro & (upa[3:0] == 4'b0011); // 43-read
// Read to clear:
wire                   upen_cntr2c1 = upen_cntr2c & (upa[3:0] == 4'b0001); // 51-error
wire                   upen_cntr2c2 = upen_cntr2c & (upa[3:0] == 4'b0010); // 52-write
wire                   upen_cntr2c3 = upen_cntr2c & (upa[3:0] == 4'b0011); // 53-read
////////////////////////////////////////////////////////////////////////////////
wire                   upen_ctl0 = upen_ctl & (upa[3:0] == 4'b0000); // 10 => Address range.
wire                   upen_ctl1 = upen_ctl & (upa[3:0] == 4'b0001); // 11 => Wait counter.
wire                   upen_ctl2 = upen_ctl & (upa[3:0] == 4'b0010); // 12 => fix addr test, Maximun 32 bit
wire                   upen_ctl3 = upen_ctl & (upa[3:0] == 4'b0011); // 13 => fix data-1 test,ddr Len
wire                   upen_ctl4 = upen_ctl & (upa[3:0] == 4'b0100); // 14 => fix data-2 test,ddr Len 
// global 0
wire [31:0]            out_glb0;
wire [31:0]            updo_glb0;
// [0] test enable
// [1] diag enable => output for top sel rtlcore
// [2:3] 
pconfigx #(32,32'h0000_00a0) pcfg_glb0
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_glb0),//0x00 --> bit[1]
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_glb0[31:0]),
     .updo  (updo_glb0[31:0])
     );
// 0-3 
assign                 ddrtest_en    = out_glb0[0];
assign                 force_dataerr = out_glb0[1];
assign                 ddrtestmode   = out_glb0[3:2];
// 4-7
assign                 data_mod      = out_glb0[5:4]; // 00/Fix/INC/PRBS
assign                 addr_mod      = out_glb0[7:6]; // 00/Fix/INC/..
// global 1
wire [15:0]            updo_glb1;
wire [15:0]            out_glb1;
wire [15:0]            oerrstatus;

stickyx #(16)   sticky_glb1
    (
     .clk       (clk),
     .rst_      (rst_),
     .upactive  (test_en),
     
     .alarm     ({oerrstatus}),
     
     .upen      (upen_glb1), // 01
     .upws      (upws),
     .updi      (updi[15:0]),
     .updo      (updo_glb1 [15:0]),
     .lalarm    (out_glb1 [15:0])
     );
assign                 uprdy_glb = (upen_glb & (uprs || upws));
wire [31:0]            updo_glb;
assign                 updo_glb = (updo_glb0 | updo_glb1);
////////////////////////////////////////////////////////////////////////////////
// config test AUTO or Manual:
// control-0 #reg 10
wire [31:0]            out_ctl0;
wire [31:0]            updo_ctl0;

pconfigx #(32,32'h0000_0004) pcfg_ctl0
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_ctl0),//0x10
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_ctl0[31:0]),
     .updo  (updo_ctl0[31:0])
     );
assign                 addr_range   = out_ctl0[15:0];
////////////////////////////////////////////////////////////////////////////////
// control-1 #reg 11
wire [31:0]            out_ctl1;
wire [31:0]            updo_ctl1;

pconfigx #(32,32'h0000_0007) pcfg_ctl1
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_ctl1),//0x11
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_ctl1[31:0]),
     .updo  (updo_ctl1[31:0])
     );
assign                 wait_clk = out_ctl1[7:0];
// config addr fix
wire [31:0]            out_ctl2;
wire [31:0]            updo_ctl2;
pconfigx #(32,32'hAA55_A5A5) pcfg_ctl2
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_ctl2),//0x12
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_ctl2[31:0]),
     .updo  (updo_ctl2[31:0])
     );
assign                 fix_addr = out_ctl2;
// config data1 fix
wire [31:0]            out_ctl3;
wire [31:0]            updo_ctl3;
pconfigx #(32,32'hA5A5_AA55) pcfg_ctl3
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_ctl3),//0x13
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_ctl3[31:0]),
     .updo  (updo_ctl3[31:0])
     );
assign                 fixdat1 = out_ctl3;
// config data2 fix
wire [31:0]            out_ctl4;
wire [31:0]            updo_ctl4;
pconfigx #(32,32'hC3C3_CC33) pcfg_ctl4
    (
     .clk   (clk),
     .rst_  (rst_),
     .upen  (upen_ctl4),//0x14
     .upws  (upws),
     .updi  (updi[31:0]),
     .out   (out_ctl4[31:0]),
     .updo  (updo_ctl4[31:0])
     );
assign                 fixdat2 = out_ctl4;
//------------------------------------------------------------------------------
// Alarm ------------------------------------------------------------------------------------
// [0] - DDR calib OK,
// [1] - rd data error,
// [2] - fifo full
// [3] - fifo empty.
wire                   rd_req,wr_req;
wire                   rddat_err,fifo_full,fifo_empty;
assign                 rddat_err  = diag_alarm[0]; // read fifo error 
assign                 fifo_full  = diag_alarm[1]; // fifo data full
assign                 fifo_empty = diag_alarm[2]; 

assign                 oerrstatus = {12'b0,
                                     ~fifo_empty,fifo_full,rddat_err,~ddrok};

assign                 rd_req = (rd_state & app_rdy);
assign                 wr_req = (wr_state & app_rdy & app_wdf_rdy);
wire                   wr_req1,rd_req1;

fflopx#(1+1) fflvalidcnt(clk,rst_,{wr_req,rd_req},{wr_req1,rd_req1});
// cnt
wire [31:0]            updo_cnt;
wire [31:0]            updo_cnt1;
wire [31:0]            updo_cnt2;
wire [31:0]            updo_cnt3;
wire [31:0]            updo_gblcnt,updo_cnt_l;
wire                   uprdy_glbcnt;
// --- cnt #1-- counter error
wire [31:0]            out_cnt1;
wire                   uprdy_cnt1;

rtldb1chcnt #(32)      i1chcnt1_eerr
    (
     .clk       (clk),
     .rst_      (rst_),

     .vld       (rddat_err),
     
     .num       (8'h0),
     .upen_ro   (upen_cntro1),
     .upen_r2c  (upen_cntr2c1),
     .uprs      (uprs),
     .uprdy     (uprdy_cnt1),
     .updo      (updo_cnt1),
     .out       (out_cnt1)
     );
// --- cnt #2-- counter write
wire [31:0]            out_cnt2;
wire                   uprdy_cnt2;

rtldb1chcnt #(32)      i1chcnt2_write
    (
     .clk       (clk),
     .rst_      (rst_),
     
     .vld       (wr_req1),
     .num       (8'h0),
     .upen_ro   (upen_cntro2),
     .upen_r2c  (upen_cntr2c2),
     .uprs      (uprs),
     .uprdy     (uprdy_cnt2),
     .updo      (updo_cnt2),
     .out       (out_cnt2)
     );
// --- cnt #3-- counter read
wire [31:0]            out_cnt3;
wire                   uprdy_cnt3;

rtldb1chcnt #(32)      i1chcnt3_read
    (
     .clk       (clk),
     .rst_      (rst_),
     
     .vld       (rd_req1),
     .num       (8'h0),
     .upen_ro   (upen_cntro3),
     .upen_r2c  (upen_cntr2c3),
     .uprs      (uprs),
     .uprdy     (uprdy_cnt3),
     .updo      (updo_cnt3),
     .out       (out_cnt3)
     );
//------------------------------------------------------------------------------
assign                 uprdy_ctl = (upen_ctl & (uprs || upws));
wire [31:0]            updo_ctl;
assign                 updo_ctl = (updo_ctl0 |
                                   updo_ctl1 |
                                   updo_ctl2 |
                                   updo_ctl3 |
                                   updo_ctl4 );

assign                 updo_gblcnt = (updo_cnt1 |
                                      updo_cnt2 | 
                                      updo_cnt3);

assign                 uprdy_glbcnt = (uprdy_cnt1 || 
                                       uprdy_cnt2 || 
                                       uprdy_cnt3);

fflopx #(1) ffuprdy_glbcnt (clk,rst_,uprdy_glbcnt,uprdy_cnt);
fflopxe #(32) fflupdocnt   (clk,rst_,uprdy_glbcnt,updo_gblcnt,updo_cnt_l);
assign                 updo_cnt = (upen_cntro | upen_cntr2c) ? updo_cnt_l : 32'h0;
////////////////////////////////////////////////////////////////////////////////
// Latch updo
wire [31:0]            l_updo;
wire [31:0]            local_updo;
assign                 local_updo = (updo_glb | 
                                     updo_ctl | 
                                     updo_cnt );

fflopxe #(32) latch_updo(clk,rst_,uprdyx,local_updo,l_updo);
assign                 updo = (~upce_) ? l_updo : 32'h0;
////////////////////////////////////////////////////////////////////////////////
// Debug
`ifdef RTL_DEBUG
(*mark_debug = "TRUE"*)     wire[ADDRW-1:0]     db_app_addr ;
(*mark_debug = "TRUE"*)     wire[2:0]           db_app_cmd ;
(*mark_debug = "TRUE"*)     wire                db_app_en ;
(*mark_debug = "TRUE"*)     wire                db_app_rdy;
(*mark_debug = "TRUE"*)     wire[DATAW-1:0]     db_app_wdf_data ;
(*mark_debug = "TRUE"*)     wire                db_app_wdf_rdy ;
(*mark_debug = "TRUE"*)     wire [DATAW-1:0]    db_app_rd_data;
(*mark_debug = "TRUE"*)     wire                db_app_rd_data_valid;
(*mark_debug = "TRUE"*)     wire                db_addr_full;
(*mark_debug = "TRUE"*)     wire                db_app_wdf_wren;// 
(*mark_debug = "TRUE"*)     wire                db_ddruser_clk;
(*mark_debug = "TRUE"*)     wire[1:0]           db_state;
(*mark_debug = "TRUE"*)     wire                db_app_rden;
(*mark_debug = "TRUE"*)     wire[15:0]          db_adrcnt;
(*mark_debug = "TRUE"*)     wire[7:0]           db_valid_cnt;         


assign                 db_adrcnt = adrcnt;
assign                 db_valid_cnt = valid_cnt;
assign                 db_app_rden = app_rden;
assign                 db_app_wdf_wren = app_wdf_wren;
assign                 db_addr_full = addr_full;
assign                 db_app_addr = app_addr;
assign                 db_app_cmd = app_cmd;
assign                 db_app_en = app_en;
assign                 db_app_rdy = app_rdy;
assign                 db_app_wdf_data = app_wdf_data;
assign                 db_app_wdf_rdy = app_wdf_rdy;
assign                 db_app_rd_data = app_rd_data;
assign                 db_ddruser_clk = clk;
assign                 db_app_rd_data_valid = app_rd_data_valid;
assign                 db_state = state;


`endif

//-End--------------------------------------------------------------------------
endmodule 
